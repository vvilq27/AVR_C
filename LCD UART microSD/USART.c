#include <avr/io.h>
#include <avr/interrupt.h>
#include "headers/USART.h"
#include "headers/LCD.h"

void USART_Init(unsigned int baud){
										//interrupts checker leds
//	DDRD |= _BV(5);						//red
//	DDRD |= _BV(6);						//yellow
//	DDRD |= _BV(7);						//green
	UBRR0H = (uint8_t) (baud>>8);		//set baud rate
	UBRR0L = (uint8_t) (baud);			//set baud rate
	UCSR0B |= (1<<RXEN0) | (1<<TXEN0)|(1<<RXCIE0);//enable receiver and transmitter
	UCSR0C |= (1<<UCSZ00) | (1<<UCSZ01);//set frame format: 8 data bits, 2 stop bits
//	USART_Init_check();
}
// display setup parameters
void USART_Init_check(void){
	lcd_cls();
	lcd_str("UCSR0A(hex): ");
	lcd_hex(UCSR0A);
	_delay_ms(1500);
	lcd_cls();
	lcd_str("UCSR0B(hex): ");
	lcd_hex(UCSR0B);
	_delay_ms(1500);
	lcd_cls();
	lcd_str("UCSR0C(hex): ");
	lcd_hex(UCSR0C);
	_delay_ms(1500);
}
//reading received and saved data stored in program buffer
//char uart_get_char(void){
//	if( UART_RxHead == UART_RxTail ){	// check if indexes are equal => no data in buffer
//		lcd_locate(1,0);
//		lcd_str("no new data");
//		return 0;
//	}
//	else{
//		UART_RxTail = (UART_RxTail + 1) & UART_RX_BUFF_MASK;//shifts read register
//		return UART_RxBuff[UART_RxTail];//output received data
//	}
//}

char* uart_get_char(void){
	if( UART_RxHead == UART_RxTail ){	// check if indexes are equal => no data in buffer
		lcd_locate(1,0);
		lcd_str("no new data");
		return 0;
	}
	else{
		volatile uint8_t i = 0;
		while( i++ <  19){
			UART_RxData[i] = 0;
		}
		while(UART_RxHead != UART_RxTail){
			UART_RxTail = (UART_RxTail + 1) & UART_RX_BUFF_MASK;//shifts read register
			UART_RxData[data_index++] = UART_RxBuff[UART_RxTail];//output received data
			if(data_index > 18)data_index=0;
		}
		return UART_RxData;
	}
}
//sends gibberish
//send char
void uart_put_char(char data){
	uint8_t tmp_head;					//pointer for putting new chars in buffer
	tmp_head = (UART_TxHead + 1) & UART_TX_BUFF_MASK;
	while( tmp_head == UART_TxTail ){
		//TODO:
	}
	UART_TxBuff[tmp_head] = data;
	UART_TxHead = tmp_head;
	UCSR0B |= (1<<UDRIE0);				//enable "send" interrupt
}
//works good
void uart_put_str(char *s ){
	while(*s)
		uart_put_char(*s++);
}

//***************************************************************
//
//						UART INTERRUPTS
//
//***************************************************************

//UART receive complete
//saving received data from hardware buffer (UDRO) to program buffer stored in RAM
ISR(USART_RX_vect){
	PORTD |= (1<<PD6);					//yellow led-checker
	uint8_t tmp_head;					//points to single char stored in RxBuff
	char data;
	data = UDR0;						// get data from UART buffer
										// new head index value; if RxHead -> 31+1=32 -> 32 & 31 bitwise gives 0, which resets our index(head)
	tmp_head = ( UART_RxHead + 1 ) & UART_RX_BUFF_MASK;
	if ( tmp_head == UART_RxTail ){
		// TODO:  handle somehow that occurance
		// like signal this error with turning on LED
	} else{
		UART_RxHead = tmp_head;			//save new pointer value
		UART_RxBuff[tmp_head] = data;	// save new char to received data buffer
	}
}

//sending data
//Data Register Empty interrupt, indicates if the transmit buffer (UDR0) is ready to receive new data.
//If UDRE0 is one, the buffer is empty, and therefore ready to be written
//generated by UDRE0 flag
ISR(USART_UDRE_vect){
	PORTD |= (1<<PD7);
	if(UART_TxHead != UART_TxTail ){
		UART_TxTail = (UART_TxTail + 1) & UART_TX_BUFF_MASK;
		UDR0 = UART_TxBuff[UART_TxTail];//put char to send
	}else {
		UCSR0B &= ~(1<<UDRIE0);//disable interrupt
	}
}
//UART TX complete interrupt
ISR(USART_TX_vect){
	PORTD |= _BV(5);//red led-checker

}
